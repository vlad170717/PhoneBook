<h2 style="text-align: center;">Description</h2>

<p>The search is pretty fast, isn't it? Is it possible to come up with something even faster?</p>

<p>In the previous stage you prepared the data by the algorithm with complexity <code>O(n log n)</code> and found the data by the algorithm with complexity <code>O(log n)</code>. At this stage you will implement faster data preparation and faster search. The preparation will have a complexity of <code>O(n)</code> and the search will have a complexity of <code>O(1)</code>. A <strong>hash table</strong> will help you with this. Implement this class by yourself.</p>

<p>You need to add all the elements to the hash table and then find the necessary phone numbers as in the previous stages. Since the hash table is filled in once, you need to measure the hash table creation time separately (this is like sorting in the previous stage).</p>

<h2 style="text-align: center;">Example</h2>

<p>Output all four approaches one after another and see which one is faster. Output example is shown below. Note that you can get totally different sorting and searching times!</p>

<pre><code>Start searching (linear search)...
Found 500 / 500 entries. Time taken: 1 min. 56 sec. 328 ms.

Start searching (bubble sort + jump search)...
Found 500 / 500 entries. Time taken: 9 min. 15 sec. 291 ms.
Sorting time: 8 min. 45 sec. 251 ms.
Searching time: 0 min. 30 sec. 40 ms.

Start searching (quick sort + binary search)...
Found 500 / 500 entries. Time taken: 1 min. 21 sec. 996 ms.
Sorting time: 1 min. 17 sec. 381 ms.
Searching time: 0 min. 4 sec. 615 ms.

Start searching (hash table)...
Found 500 / 500 entries. Time taken: 0 min. 4 sec. 256 ms.
Creating time: 0 min. 4 sec. 121 ms.
Searching time: 0 min. 0 sec. 135 ms.</code></pre>